<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Coronavirus Spring Invasion: Miami</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;

    </style>
</head>
<body>


<script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                debug: true
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    const depths = {
        GROUND: 0,
        BELOW_ENEMY: 1,
        ENEMY: 2,
        ABOVE_ENEMY: 3,
        POINTER: 4
    };
    
    var enemies;
    var debugWave = true;

    var walls;
    var lanes;

    var groundImage;

    var playerHealth = 100;
    var playerHealthText;
    var score = 0;
    var scoreText;
    var gameOverText;

    // Weapons
    const weapons = {
        BOOK: 'book',
        BUBBLE: 'bubble',
        HIRAISHIN: 'hiraishin',
        PIKACHU: 'pikachu',
        PORTAL: 'portal',
        TELEPORTER: 'teleporter',
    }
    var selectedWeapon = weapons.TELEPORTER;
    var selectedWeaponText;
    // Books
    var books;
    // Portals
    var portals;
    var portalBounds;
    var portalDuration = 5000;
    // Pikachu
    var pikachuPointer;
    var thunderAnimation;
    var thunderHitBox;
    const THUNDER_ACCURACY = 70;
    var allowCharge = true;
    var isChargingThunder = false;
    var chargePercentage = 0;
    var chargeIncrement = 10;
    var chargeLock = false;
    var chargeDelay = 500;
    var pikachuCooldown = 1000;
    var pikachuPointerDefaultAlpha = 0.5;
    // Bubbles
    var bubblePointer;
    var bubblePointerDefaultAlpha = 0.5;
    var bubbleActivated = false;

    var game = new Phaser.Game(config);
    
    function preload()
    {
        this.load.image('sky', 'assets/sky.png');
        this.load.image('ground', 'assets/testground.png');
        this.load.image('enemy', 'assets/testenemy.png');
        this.load.image('ocean', 'assets/ocean.png');
        this.load.image('sun', 'assets/sun.png');
        this.load.image('wall', 'assets/wall.png');
        this.load.image('lane', 'assets/lane.png');
        this.load.image('book', 'assets/book.png');
        this.load.image('portal_orange', 'assets/portal_orange.png');
        this.load.image('portal_mask', 'assets/portal_mask.png');
        this.load.spritesheet('pikachu', 'assets/pikachu_spritesheet.png', { 
            frameWidth: 42,
            frameHeight: 60,
            startFrame: 0,
            endFrame: 3
        });
        this.load.spritesheet('thunder', 'assets/thunder_spritesheet2.png', {
            frameWidth: 110,
            frameHeight: 230,
            startFrame: 0,
            endFrame: 5
        });
        this.load.image('thunderHitBox', 'assets/thunderHitBox.png');
        this.load.spritesheet('bubblePointer', 'assets/bubble_spritesheet.png', {
            frameWidth: 20,
            frameHeight: 20,
            startFrame: 0,
            endFrame: 3
        });
    }
    
    function create()
    {
        // Add background elements
        this.add.image(400, 300, 'sky');
        this.add.image(600, 100, 'sun').setScale(0.5);
        groundImage = this.add.image(400, 450, 'ground');
        this.add.image(400, 300, 'ocean');

        // Pointers
        pikachuPointer = this.add.sprite(400, 300, 'pikachu');
        pikachuPointer.alpha = pikachuPointerDefaultAlpha;
        pikachuPointer.visible = false;
        pikachuPointer.depth = groundImage.depth + depths.POINTER;
        this.anims.create({
            key: 'idlePika',
            frames: [ { key: 'pikachu', frame: 0 } ],
            frameRate: 20,
        });
        this.anims.create({
            key: 'chargeThunder',
            frames: this.anims.generateFrameNumbers('pikachu', { start: 1, end: 2 }),
            frameRate: 5,
            repeat: -1
        });
        this.anims.create({
            key: 'useThunder',
            frames: [ { key: 'pikachu', frame: 3 } ],
            frameRate: 20,
        });
        thunderAnimation = this.add.sprite(400, 300, 'thunder');
        thunderAnimation.visible = false;
        thunderAnimation.depth = groundImage.depth + depths.ABOVE_ENEMY;
        this.anims.create({
            key: 'thunderbolt',
            frames: this.anims.generateFrameNumbers('thunder', { start: 0, end: 4 }),
            frameRate: 10,
            repeat: 2
        });
        bubblePointer = this.physics.add.sprite(400, 300, 'bubblePointer', 0);
        bubblePointer.alpha = bubblePointerDefaultAlpha;
        bubblePointer.depth = groundImage.depth + depths.POINTER;
        this.anims.create({
            key: 'idleBubble',
            frames: [ { key: 'bubblePointer', frame: 0 } ],
            frameRate: 20
        });
        this.anims.create({
            key: 'activeBubble',
            frames: this.anims.generateFrameNumbers('bubblePointer', { start: 0, end: 3 }),
            frameRate: 10,
            repeat: -1
        });
        bubblePointer.disableBody(true, true);

        // Register keyboard inputs
        // Create key objects, which are emitOnce by default.
        // Then create listener event for the key input, which because of the created Key should only fire once.
        var key1 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ONE);
        this.input.keyboard.on('keydown_ONE', function (event) {
            selectedWeapon = weapons.TELEPORTER;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        var key2 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.TWO);
        this.input.keyboard.on('keydown_TWO', function (event) {
            selectedWeapon = weapons.BOOK;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        var key3 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.THREE);
        this.input.keyboard.on('keydown_THREE', function (event) {
            selectedWeapon = weapons.PORTAL;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        var key4 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.FOUR);
        this.input.keyboard.on('keydown_FOUR', function (event) {
            selectedWeapon = weapons.PIKACHU;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        var key5 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.FIVE);
        this.input.keyboard.on('keydown_FIVE', function (event) {
            selectedWeapon = weapons.HIRAISHIN;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        var key6 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SIX);
        this.input.keyboard.on('keydown_SIX', function (event) {
            selectedWeapon = weapons.BUBBLE;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        //var key7 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SEVEN);
        //var key8 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.EIGHT);

        var reloadKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        this.input.keyboard.on('keydown_R', function (event) {
        });

        // Instantiate physics objects

        // Create lanes
        lanes = this.physics.add.staticGroup({
            key: 'lane',
            repeat: 60,
            setXY: { x: 400, y: 300, stepY: 5 },
            visible: false
        });

        // Create walls
        walls = this.physics.add.staticGroup({
            key: 'wall',
            repeat: 60,
            setXY: { x: 500, y: 300, stepX: 3 },
            visible: false
        });
        walls.children.entries[0].visible = true;
        walls.children.entries[60].visible = true;

        // Create enemies
        enemies = this.physics.add.group();
        enemies.defaultKey = 'enemy';

        // Create out-of-play bounds (remove enemies once they hit this)
        oopBounds = this.physics.add.staticGroup();
        var oopLeft = oopBounds.create(-100, 300, 'wall');
        oopLeft.setScale(2);
        oopLeft.body.updateFromGameObject();
        var oopRight = oopBounds.create(900, 300, 'wall');
        oopRight.setScale(2);
        oopRight.body.updateFromGameObject();
        var oopTop = oopBounds.create(400, -100, 'lane');
        oopTop.setScale(2);
        oopTop.body.updateFromGameObject();
        var oopBottom = oopBounds.create(400, 700, 'lane');
        oopBottom.setScale(2);
        oopBottom.body.updateFromGameObject();

        // Create weapon object groups
        books = this.physics.add.group();
        books.defaultKey = 'book';
        
        portals = this.physics.add.staticGroup();
        portals.defaultKey = 'portal_orange';
        portalBounds = this.physics.add.staticGroup();
        portalBounds.defaultKey = 'wall';

        thunderHitBox = this.physics.add.staticGroup();
        thunderHitBox.defaultKey = 'thunderHitBox';

        this.physics.add.collider(enemies, oopBounds, hitEnemyOOP, null, this);
        this.physics.add.collider(books, oopBounds, hitOOP, null, this);

        // Add HUD elements
        scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#000' });
        playerHealthText = this.add.text(550, 16, 'Health: 100', { fontSize: '32px', fill: '#000' });
        selectedWeaponText = this.add.text(16, 40, 'Weapon: ' + weapons.TELEPORTER, { fontSize: '32px', fill: '#000' });

        // Event handlers
        // Spawn timer for the enemy
        var enemyCount;
        var waveSize = 20;
        if (!debugWave)
        {
            for (enemyCount = 0; enemyCount < waveSize; enemyCount++)
            {
                // Spawn delay essentially determines how long the wave will last
                // Enemies will be distributed across this time
                var spawnDelay = Phaser.Math.Between(100, 1000);
                this.time.addEvent(
                    { 
                        delay: spawnDelay,
                        callback: spawnEnemy,
                        callbackScope: this
                    });
            }
        }
        else
        {
            spawnEnemy.call(this, true, 20, 10);
            spawnEnemy.call(this, true, 20, 20);
            spawnEnemy.call(this, true, 30, 10);
            spawnEnemy.call(this, true, 30, 20);
            spawnEnemy.call(this, true, 40, 10);
            spawnEnemy.call(this, true, 40, 20);
            spawnEnemy.call(this, true, 50, 10);
            spawnEnemy.call(this, true, 50, 20);
        }
        // Pointer event listeners
        groundImage.setInteractive().on('pointerdown', activateWeaponOnGround, this);
        groundImage.setInteractive().on('pointerup', releaseWeaponOnGround, this);
        this.input.on('pointerdown', activateWeapon, this);
        this.input.on('pointerup', releaseWeapon, this);
        // TODO Currently will only update image if the pointer moves
        // If the weapon is switched but the pointer isn't moved, the pointer is unchanged until it does
        // We can add a step to update the image in the weapon selection logic as well
        // TODO Maybe create a pointer object that contains all the pointers for each weapon
        // And instead of an if-else statement just index based on the weapons enum
        this.input.on('pointermove', function (pointer) {

            pikachuPointer.visible = (selectedWeapon == weapons.PIKACHU);
            bubblePointer.visible = (selectedWeapon == weapons.BUBBLE);
            if (selectedWeapon == weapons.PIKACHU)
            {
                pikachuPointer.setPosition(pointer.x, pointer.y);
            }
            else if (selectedWeapon == weapons.BUBBLE)
            {
                bubblePointer.setPosition(pointer.x, pointer.y);
            }
        });
    }
    
    function update()
    {
        if (selectedWeapon == weapons.PIKACHU && isChargingThunder)
        {
            if (chargePercentage < 100 && !chargeLock)
            {
                console.log("add charge event");
                chargeLock = true;
                this.time.addEvent({
                    delay: chargeDelay,
                    callback: increaseCharge,
                    callbackScope: this
                });
            }
            pikachuPointer.alpha = pikachuPointerDefaultAlpha + 
                (1 - pikachuPointerDefaultAlpha) * (chargePercentage / 100);
        }
    }

    function increaseCharge()
    {
        chargePercentage += chargeIncrement;
        chargeLock = false;
        console.log("increase charge: " + chargePercentage);
    }

    function resetPikachu()
    {
        pikachuPointer.alpha = pikachuPointerDefaultAlpha;
        pikachuPointer.anims.play('idlePika');
        thunderAnimation.visible = false;
        allowCharge = true;
    }

    function hitWall(enemy, wall)
    {
        if (playerHealth > 0)
        {
            playerHealth -= 10;
            playerHealthText.setText('Health: ' + playerHealth);
        }

        if (playerHealth <= 0)
        {
            gameOverText = this.add.text(325, 300, 'GAME OVER', { fontSize: '50px', fill: '#000' });
            // Clean up enemies upon game over and stop spawning enemies
            //spawnTimer.remove();
            //enemies.children.iterate(function (child) {
            //    child.disableBody(true, true);
            //});
        }
    }

    function hitOOP(obj, oop)
    {
        obj.disableBody(true, true);
    }

    function hitEnemyOOP(enemy, oop)
    {
        recordEnemyKill(enemy);
    }

    function hitBook(enemy, book)
    {
        this.physics.world.removeCollider(enemy.getData('bookCollider'));
        enemy.setVelocity(-400, -400);
        enemy.setGravityY(300);
        book.setVelocityX(-150);
        book.setAngularVelocity(-360);
    }

    function hitPortal(enemy, portal)
    {
        // Let the enemy fall through its lane
        this.physics.world.removeCollider(enemy.getData('laneCollider'));
        enemy.setGravityY(300);
        // Mask the enemy as it falls through the portal
        enemy.mask = new Phaser.Display.Masks.BitmapMask(this, portal.getData('mask'));
        enemy.mask.invertAlpha = true;
        // Add bounds to enemy as it falls through the portal to prevent clipping through ground
        this.physics.add.collider(enemy, portal.getData('boundLeft'));
        this.physics.add.collider(enemy, portal.getData('boundRight'));
        // Prevent the enemy from colliding with other portals and resetting its mask
        this.physics.world.removeCollider(enemy.getData('portalCollider'));
    }

    function hitThunder(enemy, thunder)
    {
        if (Phaser.Math.Between(0, 100) < THUNDER_ACCURACY)
        {
            removeAllCollidersFromEnemy.call(this, enemy);
            var blastMagnitude = 100 / (enemy.x - thunder.x);
            console.log("blastMagnitude: " + blastMagnitude);
            enemy.setVelocity(50 * blastMagnitude, -250 * Math.abs(blastMagnitude))
            enemy.setAngularVelocity(-360);
            enemy.setGravityY(300);
            this.tweens.add({
                targets: enemy,
                duration: 1000,
                scaleX: 0.01,
                scaleY: 0.01
            });
        }
    }

    function hitBubble(enemy, bubble)
    {
        removeAllCollidersFromEnemy.call(this, enemy);
        enemy.setVelocityY(-100);
    }

    function spawnEnemy(debug, index, speed)
    {
        // Choose a random lane/wall for this enemy
        if (!debug)
        {
            index = Phaser.Math.Between(0, 59);
        }
        var l = lanes.children.entries[index];
        var w = walls.children.entries[index];

        // Instantiate enemy starting position
        var e = enemies.create();
        e.x = 0;
        e.y = l.y - l.height/2 - e.height/2;
        e.setData('startX', e.x);
        e.setData('startY', e.y);

        // Choose a random walk speed for the enemy
        if (!debug)
        {
            speed = Phaser.Math.Between(100, 200);
        }
        e.setData('speed', speed);
        e.setVelocityX(speed);

        // Add collider between the enemy and its respective lane
        var laneCollider = this.physics.add.collider(e, l, landOnGround, null, this);
        e.setData('laneCollider', laneCollider);

        // Add collider between the enemy and its respective wall
        var wallCollider = this.physics.add.collider(e, w, hitWall, null, this);
        e.setData('wallCollider', wallCollider);

        // Add collider between the enemy and weapons
        var bookCollider = this.physics.add.collider(e, books, hitBook, null, this);
        e.setData('bookCollider', bookCollider);
        var portalCollider = this.physics.add.overlap(e, portals, hitPortal, null, this);
        e.setData('portalCollider', portalCollider);
        var thunderCollider = this.physics.add.overlap(e, thunderHitBox, hitThunder, null, this);
        e.setData('thunderCollider', thunderCollider);
        var bubbleCollider = this.physics.add.overlap(e, bubblePointer, hitBubble, null, this);
        e.setData('bubbleCollider', bubbleCollider);

        // Add enemy health
        e.setData('health', 100);

        // Make enemies always on top of ground level
        e.depth = groundImage.depth + depths.ENEMY;

        // Add clicker function
        e.setInteractive().on('pointerdown', function (pointer) {
            if (selectedWeapon == weapons.TELEPORTER)
            {
                health = e.getData('health');
                health -= 100;
                if (health <= 0)
                {
                    recordEnemyKill(e);
                }
                e.setData('health', health);
                // Bounce upon being clicked
                //e.setGravityY(300);
                //e.setVelocityY(-50);
            }
        });
    }

    function recordEnemyKill(enemy)
    {
        score += 10;
        scoreText.setText('Score: ' + score);
        enemy.disableBody(true, true);
        enemy.removeInteractive();
    }

    // Reset motion for enemies once they land back on the ground
    function landOnGround(enemy, ground)
    {
        enemy.setVelocityX(enemy.getData('speed'));
        enemy.setGravityY(0);
    }

    // Handle weapon actions when mouse is clicked on the ground
    function activateWeaponOnGround()
    {
        if (selectedWeapon == weapons.BOOK)
        {
            // Map the y-position to lane, find the corresponding wall
            // Use wall x-position to be the book spawn x-position
            var pointerY = this.input.activePointer.y;
            // Subtract first lane position divided by lane increments
            var laneIndex = Phaser.Math.RoundTo(
                (pointerY - lanes.children.entries[0].y) / 
                (lanes.children.entries[1].y - lanes.children.entries[0].y), 
                0);

            var b = books.create();
            console.log(laneIndex);
            b.x = walls.children.entries[laneIndex].x;
            b.y = pointerY;
            // TODO Currently the rotation only affects the GameObject but not the hitbox. This might be OK
            b.setVelocityX(-200);
            b.setAngularVelocity(-360);
            b.setScale(0.5);
        }
        else if (selectedWeapon == weapons.PORTAL)
        {
            // TODO If portal size clips outside the ground boundaries,
            // relocate it away from the actual pointer position to something else
            var p = portals.create(this.input.activePointer.x, this.input.activePointer.y);
            // TODO Shape portal hitbox size and location based on enemy size
            // Currently hardcoding enemy size as 30x30px
            p.body.setSize(p.body.width - 60, 5);
            p.body.setOffset(30, -5);
            p.depth = groundImage.depth + depths.GROUND;
            // TODO Remove hardcode for portal mask offset
            var mask = this.make.image({
                x: p.x,
                y: p.y + 150,
                key: 'portal_mask',
                add: false
            });
            p.setData('mask', mask);

            // Set bounds on the portal to constrain enemies once they've been caught
            var pbLeft = portalBounds.create(p.x - p.width/2, p.y);
            pbLeft.visible = false;
            p.setData('boundLeft', pbLeft);
            var pbRight = portalBounds.create(p.x + p.width/2, p.y);
            pbRight.visible = false;
            p.setData('boundRight', pbRight);

            this.time.addEvent({
                delay: portalDuration,
                callback: closePortal,
                args: [p]
            });
        }
    }

    function activateWeapon()
    {
        if (selectedWeapon == weapons.PIKACHU)
        {
            if (allowCharge)
            {
                console.log("Pikachu activate");
                isChargingThunder = true;
                chargePercentage = 0;
                pikachuPointer.anims.play('chargeThunder');
            }
        }
        else if (selectedWeapon == weapons.BUBBLE)
        {
            bubbleActivated = true;
            bubblePointer.enableBody(
                true,
                this.input.activePointer.x,
                this.input.activePointer.y,
                true,
                true);
            bubblePointer.anims.play('activeBubble');
        }
    }

    function releaseWeaponOnGround()
    {
    }

    function releaseWeapon()
    {
        if (selectedWeapon == weapons.PIKACHU && isChargingThunder)
        {
            console.log("Pikachu release");
            isChargingThunder = false;
            allowCharge = false;
            pikachuPointer.anims.play('useThunder');

            var releasedOnGround = this.input.activePointer.y > (groundImage.y - groundImage.height/2);
            thunderAnimation.setScale(1 + chargePercentage / 100, 1 + chargePercentage / 100);
            thunderAnimation.x = this.input.activePointer.x;
            if (releasedOnGround)
            {
                thunderAnimation.y = this.input.activePointer.y - 
                    (thunderAnimation.height * thunderAnimation.scaleY)/2;
            }
            else
            {
                thunderAnimation.y = groundImage.y - groundImage.height/2 -
                    (thunderAnimation.height * thunderAnimation.scaleY)/2;
            }
            thunderAnimation.visible = true;
            thunderAnimation.anims.play('thunderbolt');
            this.time.addEvent({
                delay: pikachuCooldown,
                callback: resetPikachu,
                callbackScope: this
            });

            var hitBox = thunderHitBox.create();
            hitBox.x = this.input.activePointer.x;
            if (releasedOnGround)
            {
                hitBox.y = this.input.activePointer.y;
            }
            else
            {
                hitBox.y = groundImage.y - groundImage.height/2;
            }
            hitBox.setScale(1 + chargePercentage / 25, 1 + chargePercentage / 25);
            hitBox.body.updateFromGameObject();
            hitBox.visible = true;
            this.time.addEvent({
                delay: 100,
                callback: clearThunderHitBox,
                args: [hitBox]
            });
        }
        else if (selectedWeapon == weapons.BUBBLE)
        {
            bubbleActivated = false;
            bubblePointer.anims.play('idleBubble');
            bubblePointer.disableBody(true, true);
        }
    }

    function closePortal(portal)
    {
        portalBounds.remove(portal.getData('boundLeft'), true, true);
        portalBounds.remove(portal.getData('boundRight'), true, true);
        portals.remove(portal, true, true);
    }

    function clearThunderHitBox(hitbox)
    {
        thunderHitBox.remove(hitbox, true, true);
    }

    function removeAllCollidersFromEnemy(enemy)
    {
        this.physics.world.removeCollider(enemy.getData('laneCollider'));
        this.physics.world.removeCollider(enemy.getData('wallCollider'));
        this.physics.world.removeCollider(enemy.getData('bookCollider'));
        this.physics.world.removeCollider(enemy.getData('portalCollider'));
        this.physics.world.removeCollider(enemy.getData('thunderCollider'));
        this.physics.world.removeCollider(enemy.getData('bubbleCollider'));
    }

</script>

</body>
</html>
