<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Coronavirus Spring Invasion: Miami</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>


<script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };
    
    var enemies;
    var ground;
    var walls;
    var lanes;
    var playerHealth = 100;
    var playerHealthText;
    var score = 0;
    var scoreText;
    var gameOverText;
    //var spawnTimer;
    const weapons = {
        BOOK: 'book',
        BUBBLE: 'bubble',
        HIRAISHIN: 'hiraishin',
        PIKACHU: 'pikachu',
        PORTAL: 'portal',
        TELEPORTER: 'teleporter',
    }
    var selectedWeapon = weapons.TELEPORTER;
    var selectedWeaponText;

    var game = new Phaser.Game(config);
    
    function preload()
    {
        this.load.image('sky', 'assets/sky.png');
        this.load.image('ground', 'assets/testground.png');
        this.load.image('enemy', 'assets/testenemy.png');
        this.load.image('ocean', 'assets/ocean.png');
        this.load.image('sun', 'assets/sun.png');
        this.load.image('wall', 'assets/wall.png');
        this.load.image('lane', 'assets/lane.png');
        this.load.image('book', 'assets/book.png');
    }
    
    function create()
    {
        // Add background elements
        this.add.image(400, 300, 'sky');
        this.add.image(600, 100, 'sun').setScale(0.5);
        this.add.image(400, 450, 'ground');
        this.add.image(400, 300, 'ocean');

        // Register keyboard inputs
        // Create key objects, which are emitOnce by default.
        // Then create listener event for the key input, which because of the created Key should only fire once.
        var key1 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ONE);
        this.input.keyboard.on('keydown_ONE', function (event) {
            selectedWeapon = weapons.TELEPORTER;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        var key2 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.TWO);
        this.input.keyboard.on('keydown_TWO', function (event) {
            selectedWeapon = weapons.BOOK;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        var key3 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.THREE);
        this.input.keyboard.on('keydown_THREE', function (event) {
            selectedWeapon = weapons.PORTAL;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        var key4 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.FOUR);
        this.input.keyboard.on('keydown_FOUR', function (event) {
            selectedWeapon = weapons.PIKACHU;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        var key5 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.FIVE);
        this.input.keyboard.on('keydown_FIVE', function (event) {
            selectedWeapon = weapons.HIRAISHIN;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        var key6 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SIX);
        this.input.keyboard.on('keydown_SIX', function (event) {
            selectedWeapon = weapons.BUBBLE;
            selectedWeaponText.setText('Weapon: ' + selectedWeapon);
        });
        //var key7 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SEVEN);
        //var key8 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.EIGHT);

        // Instantiate physics objects

        // Create lanes
        lanes = this.physics.add.staticGroup({
            key: 'lane',
            repeat: 60,
            setXY: { x: 400, y: 300, stepY: 5 },
            visible: false
        });

        // Create walls
        walls = this.physics.add.staticGroup({
            key: 'wall',
            repeat: 60,
            setXY: { x: 500, y: 300, stepX: 3 },
            visible: false
        });
        walls.children.entries[0].visible = true;
        walls.children.entries[60].visible = true;

        // Create enemies
        enemies = this.physics.add.group();
        enemies.defaultKey = 'enemy'

        // Add HUD elements
        scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#000' });
        playerHealthText = this.add.text(550, 16, 'Health: 100', { fontSize: '32px', fill: '#000' });
        selectedWeaponText = this.add.text(16, 40, 'Weapon: ' + weapons.TELEPORTER, { fontSize: '32px', fill: '#000' });

        // Event handlers
        // Spawn timer for the enemy
        var enemyCount;
        var waveSize = 20;
        for (enemyCount = 0; enemyCount < waveSize; enemyCount++)
        {
            // Basically the wave will last from 1 to 20 seconds
            // Enemies will be distributed across this time
            var spawnDelay = Phaser.Math.Between(1000, 20000);
            this.time.addEvent(
                { 
                    delay: spawnDelay,
                    callback: spawnEnemy,
                    callbackScope: this
                });
        }
        // Click handler
    }
    
    function update()
    {
    }

    function hitWall(enemy, wall)
    {
        if (playerHealth > 0)
        {
            playerHealth -= 10;
            playerHealthText.setText('Health: ' + playerHealth);
        }

        if (playerHealth <= 0)
        {
            gameOverText = this.add.text(325, 300, 'GAME OVER', { fontSize: '50px', fill: '#000' });
            // Clean up enemies upon game over and stop spawning enemies
            //spawnTimer.remove();
            //enemies.children.iterate(function (child) {
            //    child.disableBody(true, true);
            //});
        }
    }

    function spawnEnemy()
    {
        // Choose a random lane/wall for this enemy
        var index = Phaser.Math.Between(0, 59);
        var l = lanes.children.entries[index];
        var w = walls.children.entries[index];

        // Instantiate enemy starting position
        var e = enemies.create();
        e.x = 0;
        e.y = l.y - l.height/2 - e.height/2;

        // Choose a random walk speed for the enemy
        var speed = Phaser.Math.Between(100, 200);
        e.setData('speed', speed);
        e.setVelocityX(speed);

        // Add collider between the enemy and its respective lane
        e.setData('lane', l);
        this.physics.add.collider(e, l, landOnGround, null, this);

        // Add collider between the enemy and its respective wall
        e.setData('wall', w);
        this.physics.add.collider(e, w, hitWall, null, this);

        // Add enemy health
        e.setData('health', 100);

        // Add clicker function
        e.setInteractive().on('pointerdown', function (pointer) {
            console.log(selectedWeapon);
            if (selectedWeapon == weapons.TELEPORTER)
            {
                health = e.getData('health');
                health -= 100;
                if (health <= 0)
                {
                    score += 10;
                    scoreText.setText('Score: ' + score);
                    e.disableBody(true, true);
                }
                e.setData('health', health);
                // Bounce upon being clicked
                //e.setGravityY(300);
                //e.setVelocityY(-50);
            }
        });
    }

    // Reset motion for enemies once they land back on the ground
    function landOnGround(enemy, ground)
    {
        enemy.setVelocityX(enemy.getData('speed'));
        enemy.setGravityY(0);
    }
</script>

</body>
</html>
